//MIT License
//
//Copyright (c) 2021 UPV 
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

#include "../autogeneratedWarning.svc" 

`include "axi/typedef.svh"
`include "axi/assign.svh"

#ifndef SYNTHESIS
import libnoc_pkg::*;
import axi_pkg::*;
#endif

package axi_xbar_typedef_pkg;
#ifdef SYNTHESIS 
  parameter int unsigned NoMasters         =  CFG_AXI_N_INITIATORS;
  parameter int unsigned NoSlaves          =  1; 
  parameter int unsigned AxiIdWidthSlaves  =  $clog2(CFG_AXI_N_INITIATORS);
  parameter int unsigned AxiIdWidthMasters =  AxiIdWidthSlaves + AxiIdWidthSlaves;
  parameter int unsigned AxiIdUsed         =  3; // Has to be <= AxiIdWidthMasters
  parameter int unsigned AxiAddrWidth      =  32;    // Axi Address Width
  parameter int unsigned AxiDataWidth      =  128;    // Axi Data Width
  parameter int unsigned AxiStrbWidth      =  AxiDataWidth / 8;
  parameter int unsigned AxiUserWidth      =  3;
  
  parameter int unsigned  MaxMstTrans        = 32; 
  parameter int unsigned  MaxSlvTrans        = 32; 
  parameter logic         FallThrough        = 0;  
  parameter logic [9:0]   LatencyMode        = 0; //Not used 
  parameter int unsigned  AxiIdWidthSlvPorts = AxiIdWidthSlaves; 
  parameter int unsigned  AxiIdUsedSlvPorts  = 1;
  parameter int unsigned  NoAddrRules        = 1;	
 
  typedef logic [AxiIdWidthMasters-1:0] id_mst_t;
  typedef logic [AxiIdWidthSlaves-1:0]  id_slv_t;
  typedef logic [AxiAddrWidth-1:0]      addr_t;
  typedef axi_pkg::xbar_rule_32_t       rule_t; // Has to be the same width as axi addr
  typedef logic [AxiDataWidth-1:0]      data_t;
  typedef logic [AxiStrbWidth-1:0]      strb_t;
  typedef logic [AxiUserWidth-1:0]      user_t;
#endif

  typedef logic [512-1:0] wdata_t; //WIDE-DATA data type
  typedef logic [512/8-1:0] wstrb_t; // strobe for wdata

#ifndef SYNTHESIS
  typedef logic [libnoc_pkg::axiidwidthmasters-1:0] id_mst_t;
  typedef logic [libnoc_pkg::axiidwidthslaves-1:0]  id_slv_t;
  typedef logic [libnoc_pkg::axiaddrwidth-1:0]      addr_t;
  typedef axi_pkg::xbar_rule_32_t       rule_t; // Has to be the same width as axi addr
  typedef logic [libnoc_pkg::axidatawidth-1:0]      data_t;
  typedef logic [libnoc_pkg::axistrbwidth-1:0]      strb_t;
  typedef logic [libnoc_pkg::axiuserwidth-1:0]      user_t;
#endif
  `AXI_TYPEDEF_AW_CHAN_T(aw_chan_mst_t, addr_t, id_mst_t, user_t)
  `AXI_TYPEDEF_AW_CHAN_T(aw_chan_slv_t, addr_t, id_slv_t, user_t)
  `AXI_TYPEDEF_W_CHAN_T(w_chan_t, data_t, strb_t, user_t)
  `AXI_TYPEDEF_B_CHAN_T(b_chan_mst_t, id_mst_t, user_t)
  `AXI_TYPEDEF_B_CHAN_T(b_chan_slv_t, id_slv_t, user_t)

  `AXI_TYPEDEF_AR_CHAN_T(ar_chan_mst_t, addr_t, id_mst_t, user_t)
  `AXI_TYPEDEF_AR_CHAN_T(ar_chan_slv_t, addr_t, id_slv_t, user_t)
  `AXI_TYPEDEF_R_CHAN_T(r_chan_mst_t, data_t, id_mst_t, user_t)
  `AXI_TYPEDEF_R_CHAN_T(r_chan_slv_t, data_t, id_slv_t, user_t)

  `AXI_TYPEDEF_REQ_T(mst_req_t, aw_chan_mst_t, w_chan_t, ar_chan_mst_t)
  `AXI_TYPEDEF_RESP_T(mst_resp_t, b_chan_mst_t, r_chan_mst_t)
  `AXI_TYPEDEF_REQ_T(slv_req_t, aw_chan_slv_t, w_chan_t, ar_chan_slv_t)
  `AXI_TYPEDEF_RESP_T(slv_resp_t, b_chan_slv_t, r_chan_slv_t)

//temp------------------------------------------------------------------
  `AXI_TYPEDEF_AW_CHAN_T(mst_aw_chan_t, addr_t, id_mst_t, user_t)
  `AXI_TYPEDEF_AW_CHAN_T(slv_aw_chan_t, addr_t, id_slv_t, user_t)
  `AXI_TYPEDEF_B_CHAN_T(mst_b_chan_t, id_mst_t, user_t)
  `AXI_TYPEDEF_B_CHAN_T(slv_b_chan_t, id_slv_t, user_t)
  `AXI_TYPEDEF_AR_CHAN_T(mst_ar_chan_t, addr_t, id_mst_t, user_t)
  `AXI_TYPEDEF_AR_CHAN_T(slv_ar_chan_t, addr_t, id_slv_t, user_t)
  `AXI_TYPEDEF_R_CHAN_T(mst_r_chan_t, data_t, id_mst_t, user_t)
  `AXI_TYPEDEF_R_CHAN_T(slv_r_chan_t, data_t, id_slv_t, user_t)

// definition of WIDE req/resp types
  `AXI_TYPEDEF_W_CHAN_T(w_chan_wide_t, wdata_t, wstrb_t, user_t)
  `AXI_TYPEDEF_R_CHAN_T(r_chan_slv_wide_t, wdata_t, id_slv_t, user_t)
  `AXI_TYPEDEF_REQ_T(slv_req_wide_t, aw_chan_slv_t, w_chan_wide_t, ar_chan_slv_t)
  `AXI_TYPEDEF_RESP_T(slv_resp_wide_t, b_chan_slv_t, r_chan_slv_wide_t)

endpackage
