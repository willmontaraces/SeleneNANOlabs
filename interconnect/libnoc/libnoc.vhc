--MIT License
--
--Copyright (c) 2021 UPV 
--
--Permission is hereby granted, free of charge, to any person obtaining a copy
--of this software and associated documentation files (the "Software"), to deal
--in the Software without restriction, including without limitation the rights
--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--copies of the Software, and to permit persons to whom the Software is
--furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in all
--copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--SOFTWARE.

#include "../autogeneratedWarning.vhc"
library ieee;
use ieee.std_logic_1164.all;
use ieee.math_real.all;
use ieee.numeric_std.all;

library grlib;
use grlib.stdlib.all;
use grlib.amba.all;

#ifndef SYNTHESIS
use work.axi_pkg.all;
use work.axi_xbar_typedef_pkg.all;
#endif
#ifdef SYNTHESIS
library interconnect; 
use interconnect.libnoc_pkg.all;
#endif

package libnoc is


  constant AXIDMAX :  integer := 512;

-- AXI Write Data channel signals (Dedicated AXI4)
  type axi4wide_w_mosi_type is record -- Master Output Slave Input
    data    : std_logic_vector (AXIDMAX-1 downto 0);      -- wdata
    strb    : std_logic_vector (AXIDMAX/8-1 downto 0);    -- wstrb
    last    : std_logic;                                -- wlast
    valid   : std_logic;                                -- wvalid
  end record;

  type axiwide_r_somi_type is record -- Slave Output Master Input
    id      : std_logic_vector (AXI_ID_WIDTH-1 downto 0); -- rid
    data    : std_logic_vector (AXIDMAX-1 downto 0);        -- rdata
    resp    : std_logic_vector (1 downto 0);              -- rresp
    last    : std_logic;                                  -- rlast
    valid   : std_logic;                                  -- rvalid
  end record;

-- AXI interfaces (Dedicated AXI4)
  type axi4wide_mosi_type is record -- Master Output Slave Input
    aw  : axi4_aw_mosi_type;
    w   : axi4wide_w_mosi_type;
    b   : axi_b_mosi_type;
    ar  : axi4_ar_mosi_type;
    r   : axi_r_mosi_type;
  end record;

 type axiwide_somi_type is record -- Slave Output Master Input
    aw  : axi_aw_somi_type;
    w   : axi_w_somi_type;
    b   : axi_b_somi_type;
    ar  : axi_ar_somi_type;
    r   : axiwide_r_somi_type;
  end record;
  type axiwide_somi_vector_type is array (natural range <>) of axiwide_somi_type;
  type axi4wide_mosi_vector_type is array (natural range <>) of axi4wide_mosi_type;
  type axi_somi_vector_type is array (natural range <>) of axi_somi_type; 
  type axi_mosi_vector_type is array (natural range <>) of axi_mosi_type; 
  type axi4_mosi_vector_type is array (natural range <>) of axi4_mosi_type;

  component axi_noc is
  generic(
    NoInitiators  : integer;
    NoTargets     : integer;
    ncpu          : integer
  );
  port (
    clk: in std_logic;
    rst: in std_logic;
    axi_from_target   : in  axi_somi_vector_type;
    axi_to_target     : out axi4_mosi_vector_type;
    axi_from_initiator: in  axi4_mosi_vector_type;
    axi_to_initiator  : out axi_somi_vector_type  
  );   
  end component;

  component axi_lite_noc is
  generic(
    NoInitiators  : integer;
    NoTargets     : integer
  );
  port (
    clk: in std_logic;
    rst: in std_logic;
    axi_from_target   : in  axi_somi_vector_type;
    axi_to_target     : out axi_mosi_vector_type;
    axi_from_initiator: in  axi_mosi_vector_type;
    axi_to_initiator  : out axi_somi_vector_type  
  );   
  end component;

  

#ifdef SYNTHESIS    
    --type definition
    type aw_chan_mst_t is record
      id        : std_logic_vector(AxiIdWidthMasters-1 downto 0);
      addr      : std_logic_vector(AxiAddrWidth-1      downto 0);
      len       : std_logic_vector(7 downto 0); --as per axi_pkg.sv
      size      : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      burst     : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      lock      : std_logic;
      cache     : std_logic_vector(3 downto 0); -- as per axi_pkg.sv
      prot      : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      qos       : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      region    : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      atop      : std_logic_vector(5 downto 0); --as per axi_pkg.sv
      user      : std_logic_vector(AxiUserWidth-1 downto 0);
    end record; 	

    type aw_chan_slv_t is record
      id        : std_logic_vector(AxiIdWidthSlaves-1 downto 0);
      addr      : std_logic_vector(AxiAddrWidth-1     downto 0);
      len       : std_logic_vector(7 downto 0); --as per axi_pkg.sv
      size      : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      burst     : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      lock      : std_logic;
      cache     : std_logic_vector(3 downto 0); -- as per axi_pkg.sv
      prot      : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      qos       : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      region    : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      atop      : std_logic_vector(5 downto 0); --as per axi_pkg.sv
      user      : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type w_chan_t is record
      data : std_logic_vector(AxiDataWidth-1 downto 0);
      strb : std_logic_vector(AxiStrbWidth-1 downto 0);
      last : std_logic;
      user : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type b_chan_mst_t is record
      id   : std_logic_vector(AxiIdWidthMasters-1 downto 0); 
      resp : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      user : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type b_chan_slv_t is record
      id   : std_logic_vector(AxiIdWidthSlaves-1 downto 0); 
      resp : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      user : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type ar_chan_mst_t is record
      id      : std_logic_vector(AxiIdWidthMasters-1 downto 0);
      addr    : std_logic_vector(AxiAddrWidth-1 downto 0);
      len     : std_logic_vector(7 downto 0); --as per axi_pkg.sv
      size    : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      burst   : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      lock    : std_logic;
      cache   : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      prot    : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      qos     : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      region  : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      user    : std_logic_vector(AxiUserWidth-1 downto 0);
    end record; 

    type ar_chan_slv_t is record
      id      : std_logic_vector(AxiIdWidthSlaves-1 downto 0);
      addr    : std_logic_vector(AxiAddrWidth-1 downto 0);
      len     : std_logic_vector(7 downto 0); --as per axi_pkg.sv
      size    : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      burst   : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      lock    : std_logic;
      cache   : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      prot    : std_logic_vector(2 downto 0); --as per axi_pkg.sv
      qos     : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      region  : std_logic_vector(3 downto 0); --as per axi_pkg.sv
      user    : std_logic_vector(AxiUserWidth-1 downto 0);
    end record; 

    type r_chan_mst_t is record
      id    : std_logic_vector(AxiIdWidthMasters-1 downto 0);
      data  : std_logic_vector(AxiDataWidth-1 downto 0);
      resp  : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      last  : std_logic;
      user  : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type r_chan_slv_t is record
      id    : std_logic_vector(AxiIdWidthSlaves-1 downto 0);
      data  : std_logic_vector(AxiDataWidth-1 downto 0);
      resp  : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      last  : std_logic;
      user  : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type mst_req_t is record
      aw        : aw_chan_mst_t;
      aw_valid  : std_logic;
      w         : w_chan_t;
      w_valid   : std_logic;
      b_ready   : std_logic;
      ar        : ar_chan_mst_t;
      ar_valid  : std_logic;
      r_ready   : std_logic;
    end record;

    type mst_resp_t is record
      aw_ready  : std_logic; 
      ar_ready  : std_logic; 
      w_ready   : std_logic; 
      b_valid   : std_logic; 
      b         : b_chan_mst_t; 
      r_valid   : std_logic; 
      r         : r_chan_mst_t; 
    end record;

    type slv_req_t is record
      aw        : aw_chan_slv_t;
      aw_valid  : std_logic;
      w         : w_chan_t;
      w_valid   : std_logic;
      b_ready   : std_logic;
      ar        : ar_chan_slv_t;
      ar_valid  : std_logic;
      r_ready   : std_logic;
    end record;

    type slv_resp_t is record
      aw_ready  : std_logic; 
      ar_ready  : std_logic; 

      w_ready   : std_logic; 
      b_valid   : std_logic; 
      b         : b_chan_slv_t; 
      r_valid   : std_logic; 
      r         : r_chan_slv_t; 
    end record;

    type w_chan_wide_t is record
      data : std_logic_vector(AxiMaxDataWidth-1 downto 0);
      strb : std_logic_vector(AxiMaxStrbWidth-1 downto 0);
      last : std_logic;
      user : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type r_chan_slv_wide_t is record
      id : std_logic_vector(AxiIdWidthSlaves-1 downto 0);
      data : std_logic_vector(AxiMaxDataWidth-1 downto 0);
      resp : std_logic_vector(1 downto 0); --as per axi_pkg.sv
      last : std_logic;
      user : std_logic_vector(AxiUserWidth-1 downto 0);
    end record;

    type slv_resp_wide_t is record
      aw_ready  : std_logic;
      ar_ready  : std_logic;

      w_ready   : std_logic;
      b_valid   : std_logic;
      b         : b_chan_slv_t;
      r_valid   : std_logic;
      r         : r_chan_slv_wide_t;
    end record;

    type slv_req_wide_t is record
      aw        : aw_chan_slv_t;
      aw_valid  : std_logic;
      w         : w_chan_wide_t;
      w_valid   : std_logic;
      b_ready   : std_logic;
      ar        : ar_chan_slv_t;
      ar_valid  : std_logic;
      r_ready   : std_logic;
    end record;
#endif

  --my types for axi_xbar usage
  type slv_req_t_vector  is Array(Natural range<>) of slv_req_t;
  type slv_resp_t_vector is Array(Natural range<>) of slv_resp_t;
  type mst_req_t_vector  is Array(Natural range<>) of mst_req_t;
  type mst_resp_t_vector is Array(Natural range<>) of mst_resp_t;
 
  component axi_xbar_wrapper is
    generic(
      NoMasters        : integer;      
      NoSlaves         : integer; 
      AxiIdWidthMasters: integer; 
      AxiIdUsed        : integer; 
      AxiIdWidthSlaves : integer; 
      AxiAddrWidth     : integer; 
      AxiDataWidth     : integer; 
      AxiStrbWidth     : integer; 
      AxiUserWidth     : integer; 
      MaxMstTrans      : integer; 
      MaxSlvTrans      : integer; 
      FallThrough      : std_logic; 
      LatencyMode      : std_logic_vector(9 downto 0);
      AxiIdWidthSlvPorts: integer;
      AxiIdUsedSlvPorts : integer;
      NoAddrRules       : integer
    );
    port (
      clk_i     : in std_logic;
      rst_ni    : in std_logic; 
      test_i    : in std_logic;
      slv_ports_req_i : in  slv_req_t_vector  (NoMasters-1 downto 0); 
      slv_ports_resp_o: out slv_resp_t_vector (NoMasters-1 downto 0); 
      mst_ports_req_o : out mst_req_t_vector  (NoSlaves -1 downto 0); 
      mst_ports_resp_i: in  mst_resp_t_vector (NoSlaves -1 downto 0)
   );
  end component;

  component axi_xbar_lite_wrapper is
    generic(
      NoMasters        : integer;      
      NoSlaves         : integer; 
      AxiAddrWidth     : integer; 
      AxiDataWidth     : integer; 
      AxiStrbWidth     : integer; 
      MaxMstTrans      : integer; 
      MaxSlvTrans      : integer
    );
    port (
      clk_i     : in std_logic;
      rst_ni    : in std_logic; 
      test_i    : in std_logic;
      slv_ports_req_i : in  slv_req_t_vector  (NoMasters-1 downto 0); 
      slv_ports_resp_o: out slv_resp_t_vector (NoMasters-1 downto 0); 
      mst_ports_req_o : out mst_req_t_vector  (NoSlaves -1 downto 0); 
      mst_ports_resp_i: in  mst_resp_t_vector (NoSlaves -1 downto 0)
   );
  end component;

  component width_converter_wrapper is
   generic (
     AxiMaxReads         : integer;         
     AxiSlvPortDataWidth : integer;  
     AxiMstPortDataWidth : integer;
     AxiAddrWidth        : integer; 
     AxiIdWidth          : integer
    ); 
   port (
    clk_i       : in std_logic;
    rst_ni      : in std_logic;
    slv_req_i   : in slv_req_wide_t; 
    slv_resp_o  : out slv_resp_wide_t;
    mst_req_o   : out slv_req_t;
    mst_resp_i  : in slv_resp_t
   );
   end component;
  
  component axi_dw_wrapper is
   generic(
     AxiMaxReads         : integer;        
     AxiSlvPortDataWidth : integer; 
     AxiMstPortDataWidth : integer
   );
  port (
    clk: in std_logic;
    rst: in std_logic;
    axi_component_in   : in  axi4wide_mosi_type;
    axi_component_out  : out axiwide_somi_type;
    axi_from_noc: in  axi_somi_type;
    axi_to_noc  : out axi4_mosi_type  
  );   
  end component;

end package;
